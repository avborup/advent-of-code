tiles = [tuple(line.nums()) for line in input().lines()];

fn area(rect) {
  (ax, ay), (bx, by) = rect;
  (1 + abs(ax - bx)) * (1 + abs(ay - by))
};

max_area = 0;
rects = [[(tiles[i], tiles[j]) for j in i+1..tiles.len()] for i in ..tiles.len()].flat();
rects.sort(area).reverse();

print("Part 1:", area(rects.first()));

edges = [(tiles[i], tiles[i+1]) for i in -1..tiles.len()-1];

fn is_inside_polygon(point) {
  (x, y), crossings = point, 0;

  for (_ax, _ay), (_bx, _by) in edges {
    min_x, max_x = min(_ax, _bx), max(_ax, _bx);
    min_y, max_y = min(_ay, _by), max(_ay, _by);

    if x in (min_x..=max_x) and y in (min_y..=max_y) {
      if (x == _ax and x == _bx) or (y == _ay and y == _by) {
        return true;
      };
    };

    crossings += 1 if _ax == _bx and _ax > x and y in (min_y+1..=max_y);
  };
 
  return crossings % 2 == 1;
};

fn segment_crosses_edge(side) {
  (x1, y1), (x2, y2) = side;

  for (_ax, _ay), (_bx, _by) in edges {
    if y1 == y2 {  # Horizontal segment
      if _ax == _bx {  # Vertical edge
        seg_min_x, seg_max_x = min(x1, x2), max(x1, x2);
        edge_min_y, edge_max_y = min(_ay, _by), max(_ay, _by);
        # Crosses if edge is strictly between segment endpoints
        # and segment y is strictly within edge range
        if _ax in (seg_min_x+1..seg_max_x) and y1 in (edge_min_y+1..edge_max_y) {
          return true;
        };
      };
    } else if x1 == x2 {
      if _ay == _by {  # Horizontal edge
        seg_min_y, seg_max_y = min(y1, y2), max(y1, y2);
        edge_min_x, edge_max_x = min(_ax, _bx), max(_ax, _bx);
        if _ay in (seg_min_y+1..seg_max_y) and x1 in (edge_min_x+1..edge_max_x) {
          return true;
        };
      };
    };
  };

  return false;
};

fn rect_is_inside(rect) {
  (ax, ay), (bx, by) = rect;
  corners = [(ax, ay), (ax, by), (bx, ay), (bx, by)];

  for corner in corners {
    return false if not is_inside_polygon(corner);
  };

  sides = [((ax, ay), (ax, by)), ((ax, by), (bx, by)),
           ((bx, by), (bx, ay)), ((bx, ay), (ax, ay))];

  for side in sides {
    return false if segment_crosses_edge(side);
  };

  true
};

for rect in rects {
  break if rect_is_inside(rect);
};

print("Part 2:", area(rect));
